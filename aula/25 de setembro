//////////////////////////////////////////////////////////////////////////////
--------------------------------- qual o resultafdo desse codigo?

void troca(int *a, int *b) {
  int temp;
  *a = *b;
  *b = temp;
  a = NULL;               
}


int v1 = 10, v2 = 8;
int* p = &v1;
troca(p, &2);
printf("%d, %d", v1, v2);

--------------------------------- saída: 8, 10
////////////////////////////////////////////////////////////////////////////////
--------------------------------- qual o resultado desse codigo?

void troca(int *a, int *b) {
  int temp;
  *a = *b;
  *b = temp;
  a = NULL; 
  a = malloc(sizeof(int));    // 
  *a = 50;
}


int v2 = 8;
int* p = v1;
p = malloc(sizeof(int));
troca(p, &2);
printf("%d, %d", *p, v2);

--------------------------------- saída: 8, 10
///////////////////// AAAAAAAAAARGGGGGGGGGG N ENTENDI NADA 

typedef int* pint;
void troca (pint p) {
  p = NULL; //mudar aqui, tanto faz porque n sai dessa função - não faz efeito
}

Dado pint p = malloc(sizeof(int));
troca(p);
printf("%p", a);

///////////////// PILHA

Pilhas são TAD que permitem a inserção e remoção de elementos, dada a regra: "sempre que houver uma remoção, o elemento a remover será o mais recente ou o último que foi inserido na estrutura"
O último que entrou foi o primeiro a sair (LIFO - Last In, First Out) 

------------------ primeira forma de fazer isso: Vetores
Push = inserir elemento no topo da fila == pilha[t++] = y;
Pop = remover elemento do topo da fila == x = pilha[--t];
Peek = obter o valor do topo sem remover; == x = pilha[t-1]

Implementação com vetores:

t como índice = ultimo elemento da pilha (se estiver vazio, t = -1) - o primeiro elemento de um vetor é 0, então se n tem nad ano zero, o indice indica -1
t como tamanho da pilha - capacidade maxima que você pode ter (se estiver vazio, t = 0)

---------------- 

y = 'I';
pilha[t++] = y;
(se o tamanho inicial da pilha era 8, o elemento 'I' é adicionado no espaço 8 e t vira 9);
x = pilha[--t]; (x vira 'I' e t volta a ser 8 - os proximos espaços estão vazios)
(no peek, se fizer t--, o t vai mover e vou perder o que estiver armazenado no ultimo indice, por isso fazemos t-1)
(se voce chegar no final da pilha mas ainda quer usar (adicionar) algo, voce pode cidar REALLOC -- se tiver alguma variavel que aponta para as memorias ANTES de dar realloc, elas continuam apontando para esse 
            mesmoe spaço de memoria -- ao dar realloc, voce precisa mudar a variavel que apontava para essa memoria, porque ela pode ter mudado de lugar para conseguir comportar todos os espaços pedidos

------------------------------- um exemplo de pilha :D
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  int *data;      // ponteiro para armazenar os elementos da pilha
  int topo;       // indice do topo da pilha
  int capacidade; // capacidade atual da pilha - você ve se precisa extender a capacidade 
} Pilha;
---------------------------------------
// Função para inicializar a pilha com uma capacidade inicial
void init(Pilha *pilha, int capacidade) {
  pilha->data = (int *)malloc(capacidade * sizeof(int));
  pilha->topo = -1; //para saber que a pilha estva vazia 
  pilha->capacidade = capacidade;
}

// Função para verificar se a pilha esta vazia
int vazia(Pilha *pilha) {
  return pilha->topo == -1;
}

// Função para redimensionar a pilha dinamicamente
void aumentar_capacidade(Pilha *pilha) {
  pilha->capacidade *= 2;
  pilha->data = (int *)realloc(pilha->data, pilha->capacidade *sizeof(int));
}

// Função para liberar a memoria alocada pela pilha
void free_pilha(Pilha *pilha) {
  free(pilha->data);
  pilha->topo = pilha->capacidade = -1;
}

// Função para adicionar um elemento ao topo da pilha
void push(Pilha *pilha, int valor) {
  if (pilha-> topo == pilh->capacidade -1) {
    aumentar_capacidade(pilha);
  }
  pilha->data[++pilha->topo} = valor;
}

// Função para remover e retornar o elemento do topo da pilha
int pop(Pilha *pilha) {
  if (!vazia(pilha)) // se a pilha não esta vazia
    return pilha->data[pilha->topo--];
  printf("Erro: Pilha vazia. \n"); // para o usuario saber se a pilha esta vazia
}

//Função para retornar o elemento do topo da pilha sem remove-lo
int peek(Pilha *pilha) {
  if (vazia(pilha)) {
    printf("Erro: Pilha vazia. \n");
    exit(1);          // exit 1 significa erro --- exit 0 significa que o codigo rodou sem problemas
  }
  return pilha->data[pilha->topo];

//UM EXEMPLO DE USO DE PILHA - PILHAS: VETOR DINÂMICO
int main() {
  Pilha pilha;
  init(&pilha, 2); // incializa pilha com capacidade 2
  push(&pilha, 10);
  push(&pilha, 20);
  push(&pilha, 30); // aqui, pilha sera redimensionada

  printf("Elemento no topo: %d\n", peek(&pilha)); // imprime 30
  printf("Removendo: %d\n", pop(&pilha)); // remove 30
  printf("Elemento no topo: %d\n", peek(&pilha)); //imprimri 20

  free_pilha(&pilha); // liberar a memoria da pilha -- libera só pilha data (indicado pela finção free_pilha que definimos antes) 
         // se aqui ele der um pilha->topo = 5 vai estar errado, porque pilha não é ponteiro para dar -> (teria que escrever pilha.topo = 5) --- o erro foi na formatação, ele valeria se fosse pilha.topo
  return 0;
}

--------------------------------------------
// variavel de diferentes tipos
int main() {
char x = 'A';
int y = x; // o proprio compilador entende que precisa mudar o tipo de variavel
printf("Hello World  %d", y);
return 0;
}

vai sair Hello World 65 
teoricamente, deveria fazer 

int main() {
char x = 'A';
int y = (int)x; // alguns compiladores não possuem essa função automatica, então precisava indicar para que tipo de variavel voce estava mudando
printf("Hello World  %d", y);
return 0;
}







