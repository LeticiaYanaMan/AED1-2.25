CRIANDO STRUCTS E ACESSANDO

--  CRIANDO
struct estudante {
  char nomes[100];
  float nota;
  int idade;
}

--  ACESSANDO NORMAL
struct estudante batatinha; 
batatinha.idade = 20;

--  ACESSANDO VETOR
struct estudante batatinhas[20];
batatinhas[49].idade = 10;

--  QUESTÃO DE PROVA - TA CERTO? 
for (int i = 0, i < 50, batatinhas[i].idade = 0, i++) -- todos os batatinhas começam iguais a 0
for (int i = 0, i < 50, batatinhas[i].idade = 0, ++i) --- todos os batatinhas começam iguais a 0, menos o que tem i = 0     

o "for" tem tres campos - no primeiro campo, tem a inicializaçao - no segundo, tem a condiçao de parada -
no terceiro, tem o passo que segue pra avançar com o for 
  --  na teoria, colocar 
  int i = 20;
  for ( , i < 20, )
  i = i + 1;
  --  ta certo, mas n é bonito --- so tem um comando (uma linha de codigo), entao não precisa colocar chaves 

--  QUESTÃO DE PROVA - QUAL DAS ALTERNATIVAS
int i = 2;
for (, i < 21, printf("%d", i), i++);
   a) Erro
   b) imprime i = 20;
   c) imprime i = 21;
   d) NPI (nenhuma das anteriores) (nenhuma porra de ideia, adorei)
   e) nenhuma das anteriores

   resposta: e) vai imprimir do 2 ao 20 --- se i fosse 20, iria imprimir só o 20.

   for (, i < 21, printf("%d", i), ++i); --- imprime 21 --- primeiro faz a soma, depois usa o i

--  APELIDOS
struct nome {
  tipo membro1;
  tipo membro2;
  ...
}
struct nome nomeVariavel;

ou 

struct ddmmaa {
  int dia;
  int mes;
  int ano;
}
typedef struct ddmmaa data;

data niver;
niver.dia = 9;
printf("%d", niver.dia);
scanf("%d", &niver.dia);
data niver = { 9, 9, 25};

---

struct estudante {
  char nome[100];
  tipo1 membro1;
}
typedef estudante aluno

aluno.fulano = {"Fulanito", 20, 9.8};

--- o typedef serve para mais coisas, como

typedef int inteiro;
inteiro i = 0;
inteiro i[20];
