void troca (int a, int b) {
  int temp;
  temp = a;
  a= b;
  b = temp;
}

se x = 10 e y = b, troca(x,y), vai sair 10 e 20

void troca (int *a, int *b) {
  int temp;
  temp = *a;
  *a = *b;
  *b = temp;
}

com ponteiros, ele realmente troca o endereço e tem efeito fora da função 

------------------------------------------------------

podemos usar ponteiros para percorrer vetores
memoria do vetor = memoria do primeiro elemento

int *p
p = vet --- vai receber o endereço do primerio elemento (ou vet[0])
*(p+4) --- vai para o quinto elemento do vetor (0 - 1 - 2- 3- 4)
p++ corresponde a p = p + 1

quando der printf("%d", *p = *(p+3));, vai imprimir o valor do resultado do primeiro elemento (que é indicado por p) com o quarto elemento (o indicapor por p é 0 e soma 3 - fica o quarto termo)  

--------------------------------------------------------------
NOVA BIBLIOTECA <stdlib.h>
alocação dinamica

malloc -- memory allocation -- aloca um bloco de (size) bytes
char "character" = (char*) malloc1; -- estou alocando um character (um byte)
int *arr = (int*) malloc(5 * sizeof(int)); -- estou alocando 5 blocos de int (se int equivale a 2 blocos, estou alocando 10)


data *d;
d = malloc (sizeof(data));
if (d == NULL) {
  printf("malloc devolveu NULL\n");
  exit (EXIT_FAILURE);
} ----- precisa ver se conseguiu alocar memoria - a memoria é finita, então se não conseguir alocar, ele vai devolver NULL

void troca() {
  int * vetor = malloc(10000 * sizeof(int));
  free(vetor); ---- como senão estivesse mais usando a memoria, então ela é liberada para ser usada --- sem essa função, você perde essa memoria --- recebe um ponteiro, não de uma variavel estatica 
  return;
}

calloc -- memoria que inicia com bytes em 0 
int *arr = (int*) calloc(5, sizeof(int));

realloc -- realoca a memoria que voce pediu -- mudar o tamanho da memoria do array
     aloquei um vetor com 6 espaços - a memoria depois do vetor continua, só n esta reservada para o vetor - no caso, esse espaço de memoria depois do vetor esta ocupada --- com o realloc, 
          eu consigo deslocar o tamanho do array (vetor) - caso a memoria que ele usaria já esta sendo usada, ele muda de endereço e procura um lugar na memoria onde consegue abrigar um vetor do tamanho que 
          preciso 
arr = (int *) malloc(arr, 10 *sizeof(int));
                  
------------------------------------------------

int *v;
int n;
scanf("%d", &n);
v = malloc (n * sizeof(int));
for (int i = 0; i < n; ==i)
  scanf("%d", &v[i]);
...
free(v); --- se tiver um ponteiro apontando para um vetor com uma memoria que foi liberada, vai dar ERRO - se voce declarou antes, não vai mudar o ponteiro, portanto quando vc tentar acessar, vai dar erro
v = null; --- o ponteiro não armazena mais um endereço que pode ter sido liberado

----------------------------------

int *v = NULL; --- inicializou o ponteiro com 0;
v = (int *) realloc(v, (n+1)*sizeof(int)); --- pode ser (n-1) --- voce pode aumentar ou diminuir o tamanho do array que quiser

se o v já tem a memoria, ele vai tentar aumentar mais o endereço nesse mesmo lugar que está --- se não tiver, vai buscar no lugar onde quer 

--------------------------------
MATRIZES (ponteiros de ponteiros)

int **M;
M = (int **) malloc (m * sizeof(int *));
for (int i = 0; i < m; ++i)
  M[i] = (int *) malloc (n * sizeof(int)); --- entrega um endereço de memoria do tipo ponteiro int 



(int *) - transforma em ponteiro 
(int **) - transforma em ponteiro de ponteiro
char x = 'A';
int t = x; --- não posso fazer isso porque um é do tipo char e outro é do tipo int --- podemos forçar essa interpretação do char como inteiro
int t = (int)x; --- vai entregar x, que er achar, transformado em int (deixado espeficifado com parenteses na frente)
ele não vai pedir isso na prova, tipo ele n vai descontar nota se esquecer, mas pode ser que ele pergunte

malloc - serve para qualquer ponteiro que você tiver

int ** M - o endereço de memoria do endereço de memoria é N.;
estudar mais essa parte de matrizes bidimensionais v





















