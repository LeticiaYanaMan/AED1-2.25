void troca (int a, int b) {
  int temp;
  temp = a;
  a= b;
  b = temp;
}

se x = 10 e y = b, troca(x,y), vai sair 10 e 20

void troca (int *a, int *b) {
  int temp;
  temp = *a;
  *a = *b;
  *b = temp;
}

com ponteiros, ele realmente troca o endereço e tem efeito fora da função 

------------------------------------------------------

podemos usar ponteiros para percorrer vetores
memoria do vetor = memoria do primeiro elemento

int *p
p = vet --- vai receber o endereço do primerio elemento (ou vet[0])
*(p+4) --- vai para o quinto elemento do vetor (0 - 1 - 2- 3- 4)
p++ corresponde a p = p + 1

quando der printf("%d", *p = *(p+3));, vai imprimir o valor do resultado do primeiro elemento (que é indicado por p) com o quarto elemento (o indicapor por p é 0 e soma 3 - fica o quarto termo)  

--------------------------------------------------------------

alocação dinamica
malloc -- memory allocation -- aloca um bloco de (size) bytes
char "character" = (char*) malloc1; -- estou alocando um character (um byte)
int *arr = (int*) malloc(5 * sizeof(int)); -- estou alocando 5 blocos de int (se int equivale a 2 blocos, estou alocando 10)


data *d;
d = malloc (sizeof(data));
if (d == NULL) {
  printf("malloc devolveu NULL\n");
  exit (EXIT_FAILURE);
} ----- precisa ver se conseguiu alocar memoria - a memoria é finita, então se não conseguir alocar, ele vai devolver NULL













