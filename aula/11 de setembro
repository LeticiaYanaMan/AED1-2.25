prova semana que vem: dia 18 de setembro

--- testar o codigo:
int a, i;
i = 0;
a = 10;
printf("%d", i);
a += i++;
// testas a diferença dessa ultima linha:
a = a + i++; 
ou 
a = a + ++i;

--- testar os codigos que ele colocou no classroom (OnlineGDB) como aulas 3 e 4

--- testar esse codigo tbm - acho que é um dos que ele colocou no classroom 
int vetor[11];
int i = 0;
int x = 0;
for ( , i < 10, x = ++i, vetor[i] = x); // assim, vai imprimir (0 1 2 3 4 5 6 7 8 9 10)
                                        // se colocar o i++, vai imprimir (0 0 1 2 3 4 5 6 7 8 9)
       // quando tem o + primeiro, primeiro adiciona e depois utiliza a variavel
       // quando tem o + depois da variavel, primeiro voce utiliza a variavel e depois adiciona 
// forma convencional: for (i = 0, i < 10, ++i)
// ou com while 
******************
while (i < 10) {         while (i < 10) {
   ++i;                     vetor[i] = x;
   vetor[i] = x;            ++i;
}                        } 
******************
for (, i < 11, printf("%d", vetor[i]);

// estudar e ir testando as diferenças de for e while   


--- TIPO ABSTRATO DE DADOS (TAD)

modularizaçao de codigo - duas alternativas
WET (Write everything twice) - metodo obsoleto - n é tão legal
DRY (Cont repeat yourself) - abordagem estrutural

Funçoes permitem a reutilizaçao do codigo em varios lugares
Quando utilizamos uma funçao:
- so importa que retorne o resultado
- nao como o resultado e calculado

vamos dividir o programa em tres modulos: 
cliente --- interface --- implementaçao 

****************
cliente é a pessoa que chega num predio e quer ir no dentista - fala com a interface
interface é o atendente, a fachada do predio - sabe que tem dentistas no predio e vai informar o cliente
          tem informaçao e se comunica com o dentista, mas nao é dentista 
          não sabe como funciona o processo de implementação  
******************
INTERFACE - conjunto de operaçoes/declaraçoes de um TAD
IMPLEMENTAÇAO - conjunto de algoritmos que fazem as operaçoes 
CLIENTE - chama a operaçao 

em C:
- um TAD é declarado como uma struct
- a interface é um conjunto de prototipos de funcoes que manipula a struct

arquivo .h --- header em ingles --- interface --- voce mostra o que consegue apresentar ao cliente
  é a interface
arquivo .c precisa incluir biblioteca --- quando i=for incluir o que vc colocou como arquivo .h:
     #include <arquivo.h> --- e voce acessa o codigo que voce criou 
     no arquivo c, voce tem acesso ao codigo propriamente
    é a implementaçao

o cliente e quando voce usa o arquivo que alguem criou 
      por exemplo, quando chamamos o <math.h> 
--- pesquisar a diferença de chamar <stdio.h> de "stdio.h"

hoje em dia não utilizam "goto", mas eram bastante comum
 --- se voce coloca goto -30 significa va para a linha 30
 --- é ruim porque, se vc muda algo antes dessa linha, ela muda de numero e, assim, o seu codigo fica errado

esses arquivos sao otimos porque podem ser utilizados em outros lugarese permite criar bibliotecasd e tipo uteis
o codigo fica mais simples - o cliente so se preocupa em usar funçoes e o TAD só se preocupa em disponibilizar funções
separa a implementaçao da interface - pode mudar a implementaçao sem quebrar clientes - permite fazer otimizaçoes ou adicionar novas funçoes 
o codigo fica modular - mais facil colaborar com outros programadores - arquivos menores com responsabilidade bem defnida

-------- EXERCICIO DE TAD
Faça uma struct circ que armazena as coordenadas do centro e o valor do raio de um círculo
- faça uma função que recebe um círculo e devolve o valor da sua área
- faça uma função que recebe um círculo e um fator de escala da área e devolve um circulo com o mesmo centro e o novo raio deste

Termine a implementação da struct complexo que armazena um numero complexo (parte real e imaginaria)
- Escreva as funções que fazem operações sobre numeros complexos (soma, multiplicaçao, valor absoluto, etc)

  --- PONTEIROS

MEMORIA DINAMICA - voce pode mudar
   voce ganhou uma brasilia e ão pode vender --- o que voce compra depois, n importa desde que ainda tenha a brasilia

MEMORIA ESTATICA - é o que consegue carregar
   é o que a brasilia consegue carregar, tipo 3 pessoas, 2 caixas...

quando voce cria uma variavel e coloca asterisco *, ele guarda endereços 

int x = -5;
int *p = &x; --- criou um ponteiro --- quando usa, voce acessa o conteudo da memoria do ponteiro

ENDEREÇAMENTO --- endereça para ontros pontos na memoria 

o tipo do ponteiro (int, float, char, double) indica o tipo armazenado no endereço apontado 
ponteiros tambem sao variaveis, que guardam endereços

**********
int v;
v = 9;
int *p;
p - &v; // ta sem o asterisco mesmo --- fala do endereço
printf(... *p) /// quero ver o conteudo que ele endereça --- ele vai acessar a memoria de p ate chegar num endereço, que aponta o endereço que indica

*p = 7; // quando coloco o asterisco, estou falando do conteudo (que ele aponta) --- ele vai trocar o valor de onde estou apontando para 7
   // não trocou o endereço, troca o valor do espa;o de memoria para o qual ele esta apontando 

p = 0; // como nao tem asterisco, ele troca o valor da variavel p --- 0 significa nul 

*************

se fosse
********
int v = 65;
char *p;
// quando for imprimir, como pegou o numero 65 como char, ele vai interpretar como 'A'
********








